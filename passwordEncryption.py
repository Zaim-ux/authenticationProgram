from Crypto.Protocol.KDF import PBKDF2
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad

masterPassword = "Romulus"

def encryptPassword(password):
    #Generates a salt to append to the password so that an encryption key can be generated
    salt = get_random_bytes(16)
    key = PBKDF2(masterPassword, salt, dkLen=32)
    
    #The encryption key is used to generate a cipher to run the users password through
    cipher = AES.new(key, AES.MODE_CBC)
    
    #cipher text is generated by passing the users password through the encryption through the 
    #cipher and adding padding if the encrypted output wasn't big enough to fill the block
    cipherText = cipher.encrypt(pad(password.encode(), AES.block_size))
    
    return salt, cipher.iv + cipherText


def decryptPassword(password, salt):
    #IV and actual encyption of the password is retrieved
    #IV is the first 16 characters of the cipher text
    #the actual encrypted password is the last 16 charaters
    initialisationVector = password[:16]
    encryptedPassword  = password[16:]
    
    #same key and cipher is generated using the same master password and salt
    key = PBKDF2(masterPassword, salt, dkLen=32)
    cipher = AES.new(key, AES.MODE_CBC, iv=initialisationVector)
    
    #encrypted text is put through the cipher again to obtain the original password
    decryptedData = cipher.decrypt(encryptedPassword)
    plainText = unpad(decryptedData, AES.block_size).decode()
    
    return plainText
    
    
    